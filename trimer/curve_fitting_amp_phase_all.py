#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Tue Jul 16 11:31:59 2024@author: lydiabullock"""import osimport numpy as npimport matplotlib.pyplot as pltimport lmfitimport warningsfrom Trimer_simulator import curve1, theta1, curve2, theta2, curve3, theta3, c1, t1, c2, t2, c3, t3''' 3 functions contained:    multiple_fit - Curve fits to multiple Amplitude and Phase Curves at once                 - Calculates systematic error and returns a dictionary of info                 - Graphs curve fit analysis    residuals - calculates residuals of multiple data sets and concatenates them              - used in multiple_fit function to minimize the residuals of                 multiple graphs at the same time to find the best fit curve    save_figure - saves the curve fit graph created to a named folder    syserr - calculates systematic error    rsqrd - calculates R^2'''def syserr(x_found, x_set, absval = True):    with warnings.catch_warnings():        warnings.simplefilter('ignore')        se = 100*(x_found-x_set)/x_set    if absval:        return abs(se)    else:        return se"""This definition of R^2 can come out negative.Negative means that a flat line would fit the data better than the curve."""def rsqrd(model, data, plot=False, x=None, newfigure = True):    SSres = sum((data - model)**2)    SStot = sum((data - np.mean(data))**2)    rsqrd = 1 - (SSres/ SStot)        if plot:        if newfigure:            plt.figure()        plt.plot(x,data, 'o')        plt.plot(x, model, '--')        return rsqrd#Calculates and concatenates residuals given multiple data sets#Takes in parameters, frequency, and dependent variablesdef residuals(params, wd, Amp1_data, Amp2_data, Amp3_data, Phase1_data, Phase2_data, Phase3_data, scaled):    k1 = params['k1'].value    k2 = params['k2'].value    k3 = params['k3'].value     k4 = params['k4'].value     b1 = params['b1'].value    b2 = params['b2'].value     b3 = params['b3'].value     F = params['F'].value    m1 = params['m1'].value    m2 = params['m2'].value    m3 = params['m3'].value        modelc1 = c1(wd, k1, k2, k3, k4, b1, b2, b3, F, m1, m2, m3)    modelc2 = c2(wd, k1, k2, k3, k4, b1, b2, b3, F, m1, m2, m3)    modelc3 = c3(wd, k1, k2, k3, k4, b1, b2, b3, F, m1, m2, m3)    modelt1 = t1(wd, k1, k2, k3, k4, b1, b2, b3, F, m1, m2, m3)    modelt2 = t2(wd, k1, k2, k3, k4, b1, b2, b3, F, m1, m2, m3)    modelt3 = t3(wd, k1, k2, k3, k4, b1, b2, b3, F, m1, m2, m3)        residc1 = Amp1_data - modelc1    residc2 = Amp2_data - modelc2    residc3 = Amp3_data - modelc3        residt1 = Phase1_data - modelt1    residt2 = Phase2_data - modelt2    residt3 = Phase3_data - modelt3        #Trying to scale Amp and Phase because their units are different    amp_max = max([max(residc1), max(residc2), max(residc3)])    phase_max = max([max(residt1), max(residt2), max(residt3)])        scaled_residc1 = []    scaled_residc2 = []    scaled_residc3 = []        scaled_residt1 = []    scaled_residt2 = []    scaled_residt3 = []        for amp1, amp2, amp3 in zip(residc1, residc2, residc3):        scaled_residc1.append(amp1/amp_max)        scaled_residc2.append(amp2/amp_max)        scaled_residc3.append(amp3/amp_max)            for phase1, phase2, phase3 in zip(residt1, residt2, residt3):        scaled_residt1.append(phase1/phase_max)        scaled_residt2.append(phase2/phase_max)        scaled_residt3.append(phase3/phase_max)        if scaled:        return np.concatenate((scaled_residc1, scaled_residc2, scaled_residc3, scaled_residt1, scaled_residt2, scaled_residt3))    else:        return np.concatenate((residc1, residc2, residc3, residt1, residt2, residt3))def save_figure(figure, folder_name, file_name):    # Create the folder if it does not exist    if not os.path.exists(folder_name):        os.makedirs(folder_name)        # Save the figure to the folder    file_path = os.path.join(folder_name, file_name)    figure.savefig(file_path)#Takes in a *list* of correct parameters and a *list* of the guessed parameters,#as well as error and three booleans (whether you want to apply force to one or all masses,#scale by force, or fix the force)##Returns a dataframe containing guessed parameters, recovered parameters,#and systematic errordef multiple_fit_amp_phase(params_guess, params_correct, e, force_all, fix_F, scaled, graph_folder_name, graph_name, show_curvefit_graphs = False):    ##Put params_guess and params_correct into np array    #Order added: k1, k2, k3, k4, b1, b2, b3, F,  m1, m2, m3    data_array = np.zeros(51)     data_array[:11] += np.array(params_correct)    data_array[11:22] += np.array(params_guess)             ##Create data - functions from simulator code    freq = np.linspace(0.001, 4, 300)        Amp1 = curve1(freq, data_array[0], data_array[1], data_array[2], data_array[3], data_array[4], data_array[5], data_array[6], data_array[7], data_array[8], data_array[9], data_array[10], e, force_all)    Phase1 = theta1(freq, data_array[0], data_array[1], data_array[2], data_array[3], data_array[4], data_array[5], data_array[6], data_array[7], data_array[8], data_array[9], data_array[10], e, force_all) \        + 2 * np.pi    Amp2 = curve2(freq, data_array[0], data_array[1], data_array[2], data_array[3], data_array[4], data_array[5], data_array[6], data_array[7], data_array[8], data_array[9], data_array[10], e, force_all)    Phase2 = theta2(freq, data_array[0], data_array[1], data_array[2], data_array[3], data_array[4], data_array[5], data_array[6], data_array[7], data_array[8], data_array[9], data_array[10], e, force_all) \        + 2 * np.pi    Amp3 = curve3(freq, data_array[0], data_array[1], data_array[2], data_array[3], data_array[4], data_array[5], data_array[6], data_array[7], data_array[8], data_array[9], data_array[10], e, force_all)    Phase3 = theta3(freq, data_array[0], data_array[1], data_array[2], data_array[3], data_array[4], data_array[5], data_array[6], data_array[7], data_array[8], data_array[9], data_array[10], e, force_all) \        + 2 * np.pi        #Create intial parameters    params = lmfit.Parameters()    params.add('k1', value = data_array[11], min=0)    params.add('k2', value = data_array[12], min=0)    params.add('k3', value = data_array[13], min=0)    params.add('k4', value = data_array[14], min=0)    params.add('b1', value = data_array[15], min=0)    params.add('b2', value = data_array[16], min=0)    params.add('b3', value = data_array[17], min=0)    params.add('F', value = data_array[18], min=0)    params.add('m1', value = data_array[19], min=0)    params.add('m2', value = data_array[20], min=0)    params.add('m3', value = data_array[21], min=0)        #If you plan on fixing F so it cannot be changed    if fix_F:         params['F'].vary = False            #get resulting data and fit parameters by minimizing the residuals    result = lmfit.minimize(residuals, params, args = (freq, Amp1, Amp2, Amp3, Phase1, Phase2, Phase3, scaled))    #print(lmfit.fit_report(result))        ##Add recovered parameters and systematic error    #Order added: k1, k2, k3, k4, b1, b2, b3, F,  m1, m2, m3    param_values = np.array([result.params[param].value for param in result.params])    data_array[22:33] += param_values        if fix_F == False:        scaling_factor = (data_array[7])/(result.params['F'].value)        data_array[22:33] *= scaling_factor    syserr_result = syserr(data_array[22:33], data_array[:11])    data_array[33:44] += np.array(syserr_result)        #average error    data_array[-1] += np.sum(data_array[33:44]/10) #dividing by 10 because we aren't counting the error in Force because it is 0        if show_curvefit_graphs == True:        #Create fitted y-values (for rsqrd and graphing)        k1_fit = data_array[22]        k2_fit = data_array[23]        k3_fit = data_array[24]        k4_fit = data_array[25]        b1_fit = data_array[26]        b2_fit = data_array[27]        b3_fit = data_array[28]        F_fit = data_array[29]        m1_fit = data_array[30]        m2_fit = data_array[31]        m3_fit= data_array[32]                Amp1_fitted = c1(freq, k1_fit, k2_fit, k3_fit, k4_fit, b1_fit, b2_fit, b3_fit, F_fit, m1_fit, m2_fit, m3_fit)        Amp2_fitted = c2(freq, k1_fit, k2_fit, k3_fit, k4_fit, b1_fit, b2_fit, b3_fit, F_fit, m1_fit, m2_fit, m3_fit)        Amp3_fitted = c3(freq, k1_fit, k2_fit, k3_fit, k4_fit, b1_fit, b2_fit, b3_fit, F_fit, m1_fit, m2_fit, m3_fit)        Phase1_fitted = t1(freq, k1_fit, k2_fit, k3_fit, k4_fit, b1_fit, b2_fit, b3_fit, F_fit, m1_fit, m2_fit, m3_fit)        Phase2_fitted = t2(freq, k1_fit, k2_fit, k3_fit, k4_fit, b1_fit, b2_fit, b3_fit, F_fit, m1_fit, m2_fit, m3_fit)        Phase3_fitted = t3(freq, k1_fit, k2_fit, k3_fit, k4_fit, b1_fit, b2_fit, b3_fit, F_fit, m1_fit, m2_fit, m3_fit)                #Calculate R^2 and add to data_array        Amp1_rsqrd = rsqrd(Amp1_fitted, Amp1)        Amp2_rsqrd = rsqrd(Amp2_fitted, Amp2)        Amp3_rsqrd = rsqrd(Amp3_fitted, Amp3)        Phase1_rsqrd = rsqrd(Phase1_fitted, Phase1)        Phase2_rsqrd = rsqrd(Phase2_fitted, Phase2)        Phase3_rsqrd = rsqrd(Phase3_fitted, Phase3)                data_array[44:50] += np.array([Amp1_rsqrd, Amp2_rsqrd, Amp3_rsqrd, Phase1_rsqrd, Phase2_rsqrd, Phase3_rsqrd])                        #Create intial guessed y-values (for graphing)        k1_guess = data_array[11]        k2_guess = data_array[12]        k3_guess = data_array[13]        k4_guess = data_array[14]        b1_guess = data_array[15]        b2_guess = data_array[16]         b3_guess = data_array[17]        F_guess = data_array[18]        m1_guess = data_array[19]        m2_guess = data_array[20]        m3_guess = data_array[21]                c1_guess = c1(freq, k1_guess, k2_guess, k3_guess, k4_guess, b1_guess, b2_guess, b3_guess, F_guess, m1_guess, m2_guess, m3_guess)        c2_guess = c2(freq, k1_guess, k2_guess, k3_guess, k4_guess, b1_guess, b2_guess, b3_guess, F_guess, m1_guess, m2_guess, m3_guess)        c3_guess = c3(freq, k1_guess, k2_guess, k3_guess, k4_guess, b1_guess, b2_guess, b3_guess, F_guess, m1_guess, m2_guess, m3_guess)        t1_guess = t1(freq, k1_guess, k2_guess, k3_guess, k4_guess, b1_guess, b2_guess, b3_guess, F_guess, m1_guess, m2_guess, m3_guess)        t2_guess = t2(freq, k1_guess, k2_guess, k3_guess, k4_guess, b1_guess, b2_guess, b3_guess, F_guess, m1_guess, m2_guess, m3_guess)        t3_guess = t3(freq, k1_guess, k2_guess, k3_guess, k4_guess, b1_guess, b2_guess, b3_guess, F_guess, m1_guess, m2_guess, m3_guess)                ## Begin graphing        fig = plt.figure(figsize=(16,8))        gs = fig.add_gridspec(2, 3, hspace=0.1, wspace=0.1)        ((ax1, ax2, ax3), (ax4, ax5, ax6)) = gs.subplots(sharex=True, sharey='row')                #original data        ax1.plot(freq, Amp1,'ro', alpha=0.5, markersize=5.5, label = 'Data')        ax2.plot(freq, Amp2,'bo', alpha=0.5, markersize=5.5, label = 'Data')        ax3.plot(freq, Amp3,'go', alpha=0.5, markersize=5.5, label = 'Data')        ax4.plot(freq, Phase1,'ro', alpha=0.5, markersize=5.5, label = 'Data')        ax5.plot(freq, Phase2,'bo', alpha=0.5, markersize=5.5, label = 'Data')        ax6.plot(freq, Phase3,'go', alpha=0.5, markersize=5.5, label = 'Data')                #fitted curves        ax1.plot(freq, Amp1_fitted,'c-', label='Best Fit', lw=2.5)        ax2.plot(freq, Amp2_fitted,'r-', label='Best Fit', lw=2.5)        ax3.plot(freq, Amp3_fitted,'m-', label='Best Fit', lw=2.5)        ax4.plot(freq, Phase1_fitted,'c-', label='Best Fit', lw=2.5)        ax5.plot(freq, Phase2_fitted,'r-', label='Best Fit', lw=2.5)        ax6.plot(freq, Phase3_fitted,'m-', label='Best Fit', lw=2.5)                #inital guess curves        ax1.plot(freq, c1_guess, color='#4682B4', linestyle='dashed', label='Initial Guess')        ax2.plot(freq, c2_guess, color='#4682B4', linestyle='dashed', label='Initial Guess')        ax3.plot(freq, c3_guess, color='#4682B4', linestyle='dashed', label='Initial Guess')        ax4.plot(freq, t1_guess, color='#4682B4', linestyle='dashed', label='Initial Guess')        ax5.plot(freq, t2_guess, color='#4682B4', linestyle='dashed', label='Initial Guess')        ax6.plot(freq, t3_guess, color='#4682B4', linestyle='dashed', label='Initial Guess')                        #Graph parts        if scaled:             fig.suptitle('Trimer Resonator: Amplitude and Phase (Scaled)', fontsize=16)        else:             fig.suptitle('Trimer Resonator: Amplitude and Phase (Not Scaled)', fontsize=16)                ax1.set_title('Mass 1', fontsize=14)        ax2.set_title('Mass 2', fontsize=14)        ax3.set_title('Mass 3', fontsize=14)        ax1.set_ylabel('Amplitude')        ax4.set_ylabel('Phase')                for ax in fig.get_axes():            ax.set(xlabel='Frequency')            ax.label_outer()            ax.legend()                    plt.show()        save_figure(fig, graph_folder_name, graph_name)        return data_array'''Begin Work - Does scaling the residuals change anything?'''# import pandas as pd# e = 0# force_all = False# fix_F = False#this is using System 7 of 15 Systems - 10 Freqs NetMAP Better Params# params_correct = [1.427, 6.472, 3.945, 3.024, 0.675, 0.801, 0.191, 1, 7.665, 9.161, 7.139]# params_guess = [1.1942, 5.4801, 3.2698, 3.3004, 0.7682, 0.8185, 0.1765, 1, 7.4923, 8.9932, 8.1035]# #Get the data (and the graphs)# scaled_dict = multiple_fit_amp_phase(params_guess, params_correct, e, force_all, fix_F, True, 'Scaling Amp_Phase Residuals', 'Scaled')# not_scaled_dict = multiple_fit_amp_phase(params_guess, params_correct, e, force_all, fix_F, False, 'Scaling Amp_Phase Residuals', 'Not_Scaled')# with pd.ExcelWriter('Scaling_Amp_Phase_Residuals.xlsx', engine='xlsxwriter') as writer:#     dfscaled = pd.DataFrame(scaled_dict)#     dfnotscaled = pd.DataFrame(not_scaled_dict)   #     dfscaled.to_excel(writer, sheet_name='Scaled', index=False)#     dfnotscaled.to_excel(writer, sheet_name='Not Sclaed', index=False)